<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <!-- Import js here -->
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script src="https://cdn.rawgit.com/novus/nvd3/v1.8.1/build/nv.d3.min.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
  <link rel="stylesheet" href="https://cdn.rawgit.com/novus/nvd3/v1.8.1/build/nv.d3.min.css" rel="stylesheet">
  <!-- script type="text/javascript" src="./tooltip.js"></script>

  <!-- Style here -->
  <link rel="stylesheet" href="index.css">
  <style>
   .county{
      fill: #AAFFFF;
  }

  .county-boundary {
    fill: none;
    stroke: #fff;
    stroke-linejoin: round;
  }

  .states {
    fill: none;
    stroke: #000;
    stroke-linejoin: round;
  }

  .q0-9 { fill:rgb(247,251,255); }
  .q1-9 { fill:rgb(222,235,247); }
  .q2-9 { fill:rgb(198,219,239); }
  .q3-9 { fill:rgb(158,202,225); }
  .q4-9 { fill:rgb(107,174,214); }
  .q5-9 { fill:rgb(66,146,198); }
  .q6-9 { fill:rgb(33,113,181); }
  .q7-9 { fill:rgb(8,81,156); }
  .q8-9 { fill:rgb(8,48,107); }
  
  
  .tooltip{ background-color:rgba(68,136,187,0.5);;
          margin: 10px;
          height: 50px;
          width: 150px;
          padding-left: 10px; 
          padding-top: 10px;
    -webkit-border-radius:10px;
    -moz-border-radius:10px;
    border-radius:10px;
        }
  </style>
</head>

<!-- Main code/website goes here -->
<body>
  <!-- Make sure to seperate necessary code and imports for easier readability -->
  <!-- Seperating by div's to clean up code further -->
  <div id='header'>
    <div align='center' id='title'>
      <h1 class='Arial'> 2014 Reported Escherichia coli O157 </h1>
    </div>
  </div>

  <div id='filterPanel'>
    <p> Select Strain Type </p>
    <div id='straintype'>
      <select id="strains" onchange="selected(this.selectedIndex)"></select>
        <script src="js/jquery.csv-0.71.min.js"></script>
        <script>

        </script>
    </div>

    <p> Select Region Type </p>
    <div id='countystate'>
      <select>
        <option value="county">County</option>
        <option value="state">State</option>
      </select>
    </div>
  </div>

  <div id="detailsPanel">
    <p align="center"> Total Count </p>
    <div id='totalCount'>

    </div>
    <p align="center"> Selected Date Range </p>
    <div id="dateRange">

    </div>
    <p align="center"> Recorded Outbreaks </p>
    <div id="outbreaks">

    </div>
  </div>

  <div id='map'>
    <div id='choropleth'>

    </div>
    <div id ='legend'>

    </div>
  </div>

  <div id='histogram'>
    <svg></svg>
  </div>


</body>

         <script>
var alreadyDrawing = 0;

var countySelected = 0;

var countiesFilename = "us_counties_v2.json";

var width = 1399, height = 730;
  
var projection = d3.geo.albersUsa();

var path = d3.geo.path()
    .projection(projection);

var zoom = d3.behavior.zoom()
    .translate([0,0])
    .scale(1)
    .scaleExtent([1,8])
    .on("zoom", zoomed)

var mapSvg = d3.select("#choropleth").append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(zoom);

var vector = mapSvg.append("g");

var legendSvg = d3.select('#choropleth').append("svg")
    .attr("width", width)
    .attr("height", 50)
    .attr("class", "legend");


    for (var i = 0; i < 9; i++) {
      legendSvg.append("rect")
        .attr("width", 100)
        .attr("height", 15)
        .attr("x", 300 + i * 100)
        .attr("y", 10)
        .attr("class", "q" + i + "-9");
    }


var aggrByCounty = [];

function handleDate(date) {
  var str = date.split("/");
  var monthDays = 0, 
      dayDays = parseInt(str[1]),
      x = parseInt(str[0]);

  if (x >= 1)
    monthDays += 0;
  if (x >= 2)
    monthDays += 31;
  if (x >= 3)
    monthDays += 28;
  if (x >= 4)
    monthDays += 31;
  if (x >= 5)
    monthDays += 30;
  if (x >= 6)
    monthDays += 31;
  if (x >= 7)
    monthDays += 30;
  if (x >= 8)
    monthDays += 31;
  if (x >= 9)
    monthDays += 31;
  if (x >= 10)
    monthDays += 30;
  if (x >= 11)
    monthDays += 31;
  if (x >= 12)
    monthDays += 30;

  return monthDays + dayDays - 1;
}


      d3.csv("EC_data2014_v2.csv", function(data) {
    	  
    	  var totalCount = 0;
  

			var aggrByDate = [];
			
			function county(GEOID, SourceCounty, SourceState ) {
    this.GEOID = GEOID;
    this.SourceCounty = SourceCounty;
    this.SourceState = SourceState;
    this.Occurrences = [];
  }
  
  function date (UploadDate) {
    this.UploadDate = UploadDate;
    this.Occurrences = [];
  }

  for (i = 0; i < 365; i++) {
    aggrByDate.push(new date(i));
  }
  
    	 data.forEach(function(incidence) {
    totalCount += 1;

    // Initialize occurrence object
    var occurrence = {
      UploadDate : incidence.UploadDate,  
      PFGEBlnIpattern : incidence["PFGE-BlnI-pattern"],
      PFGEXbaIpattern : incidence["PFGE-XbaI-pattern"]
    };

    var i = parseInt(incidence.GEOID);
    var j = handleDate(incidence.UploadDate);

    if (aggrByCounty[i] == null) {
      aggrByCounty[i] = new county(i, incidence.SourceCounty, incidence.SourceState);
    }
    aggrByCounty[i].Occurrences.push(occurrence);
    aggrByDate[j].Occurrences.push(occurrence);
  });



  // Draw histogram
  var data = function() {
    return d3.range(1).map(function() {
      return aggrByDate.map(stream_index);
    }).map(function(data, i) {
      return {
        key: 'Stream' + i,
        values: data
      };
    });
  }
  
  function stream_index(d, i) {
    return {x: i + 1, y: Math.max(0, d.Occurrences.length)};
  }

  chart = nv.addGraph(function() {
    var chart = nv.models.lineWithFocusChart();
    
    chart.xAxis
      .tickFormat(d3.format(',f'));
    
    chart.yAxis
      .tickFormat(d3.format(',f'));
    
    chart.y2Axis
      .tickFormat(d3.format(',f'));
    
    chart.showLegend(false);
    
    d3.select('#histogram svg')
      .datum(data())
      .transition().duration(100)
      .call(chart);
    
    return chart;
  });
    	  
    	  // TODO replace hardcoded file
    	  d3.json(countiesFilename, function(error, us) {
    // Modify individual counties
    vector.selectAll(".counties")
      .data(topojson.feature(us, us.objects.counties).features)
      .enter().append("path")
      .attr("id", "county-boundary")
      .attr("class", function(d) {
        var i = d.id;
        var numOccurrences = 0;
        if (aggrByCounty[i] == null) 
          numOccurrences = 0;
        else{
          for (var j = 0; j < aggrByCounty[i].Occurrences.length; j++) {
            numOccurrences += 1;
          }
        }
        return "q" + Math.floor((numOccurrences / 35) * 9) + "-9";
      })
      .attr("d", path)
      .style({'stroke-width': "0.2", 'stroke': "rgba(0, 0, 0, 0.4)"})
      // Add tooltips
      .call(d3.helper.tooltip(function(d) {
          var i = d.id;
          if (aggrByCounty[i] == null) {
            return "<b> No reported incidences! </b>"; 
          }
          else
            return "<b>"+ aggrByCounty[i].SourceCounty 
              + " County</b> Infected: " 
              + aggrByCounty[i].Occurrences.length;
      }));

    // Modify state borders
    vector.append("path")
      .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
      .attr("class", "states")
      .attr("d", path);
  });

  // Label legend
  for (var i = 0; i < 10; i++) {
    legendSvg.append("text")
      .attr("id", "ll" + i)
      .attr("x", 295 + i * 100)
      .attr("y", 35);

    document.getElementById("ll" + i).innerHTML = Math.floor(35/9 * i);
  }

  // Label details panel
  d3.select('#totalCount')
    .append("text")
    .attr("id", "tc");

  document.getElementById("tc").innerHTML = totalCount;

  d3.select('#dateRange')
    .append("text")
    .attr("id", "dr");

  document.getElementById("dr").innerHTML = "Jan 1 ~ Dec 31";

  d3.select('#outbreaks')
    .append("text")
    .attr("id", "ob");

  //  TODO document.getElementById("tc").innerHTML = FILLHERE;
});

      var mouseDown = 0;
document.body.onmousedown = function() { 
  ++mouseDown;
}
document.body.onmouseup = function() {
  --mouseDown;
}

function zoomed() {
  vector.attr("transform", "translate(" + d3.event.translate 
    + ")scale(" + d3.event.scale + ")");
  vector.select(".states").style("stroke-width", 1 / d3.event.scale + "px");
  vector.select("#county-boundary").style("stroke-width", 1 / d3.event.scale + "px");
}

function updatedRange(leftRange, rightRange) {
  d3.json(countiesFilename, function(error, us) {
    // Modify individual counties
    d3.selectAll('#county-boundary')
      .attr("class", function(d) {
        var i = d.id;
        var numOccurrences = 0;
        if (aggrByCounty[i] == null) 
          numOccurrences = 0;
        else{
          for (var j = 0; j < aggrByCounty[i].Occurrences.length; j++) {
            var numDays = handleDate(aggrByCounty[i].Occurrences[j].UploadDate);
            if (numDays >= leftRange && numDays <= rightRange)
              numOccurrences += 1;
          }
        }
        return "q" + Math.floor((numOccurrences / 35) * 9) + "-9";
      })
      .attr("d", path)
      .style({'stroke-width': "0.2", 'stroke': "rgba(0, 0, 0, 0.4)"})
      // Add tooltips
      .call(d3.helper.tooltip(function(d) {
          var i = d.id;
          if (aggrByCounty[i] == null) {
            return "<b> No reported incidences! </b>"; 
          }
          else
            return "<b>"+ aggrByCounty[i].SourceCounty 
              + " County</b> Infected: " 
              + aggrByCounty[i].Occurrences.length;
      }));

  });
}

      
      d3.helper = {};

      d3.helper.tooltip = function(accessor){
          return function(selection){
              var tooltipDiv;
              var bodyNode = d3.select('body').node();
              selection.on("mouseover", function(d, i){
                  // Clean up lost tooltips
                  d3.select('body').selectAll('div.tooltip').remove();
                  // Append tooltip
                  tooltipDiv = d3.select('body').append('div').attr('class', 'tooltip');
                  var absoluteMousePos = d3.mouse(bodyNode);
                  tooltipDiv.style('left', (absoluteMousePos[0] + 10)+'px')
                      .style('top', (absoluteMousePos[1] - 15)+'px')
                      .style('position', 'absolute') 
                      .style('z-index', 1001);
                  // Add text using the accessor function
                  var tooltipText = accessor(d, i) || '';
              })
              .on('mousemove', function(d, i) {
                  //Move tooltip
                  var absoluteMousePos = d3.mouse(bodyNode);
                  tooltipDiv.style('left', (absoluteMousePos[0] + 10)+'px')
                      .style('top', (absoluteMousePos[1] - 15)+'px');
                  var tooltipText = accessor(d, i) || '';
                  tooltipDiv.html(tooltipText);
              })
              .on("mouseout", function(d, i){
                  // Remove tooltip
                  tooltipDiv.remove();
              });

          };
      };
		
//=========================================================================================
//  Don't touch below, API stuff
//=========================================================================================

nv.models.lineWithFocusChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , lines2 = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , x2Axis = nv.models.axis()
        , y2Axis = nv.models.axis()
        , legend = nv.models.legend()
        , brush = d3.svg.brush()
        , tooltip = nv.models.tooltip()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 30, bottom: 30, left: 60}
        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , height2 = 50
        , useInteractiveGuideline = false
        , x
        , y
        , x2
        , y2
        , showLegend = true
        , brushExtent = null
        , noData = null
        , dispatch = d3.dispatch('brush', 'stateChange', 'changeState')
        , transitionDuration = 250
        , state = nv.utils.state()
        , defaultState = null
        ;

    var leftRange = 0
        , rightRange = 0
        ;

    lines.clipEdge(true).duration(0);
    lines2.interactive(false);
    // We don't want any points emitted for the focus chart's scatter graph.
    lines2.pointActive(function(d) { return false });
    xAxis.orient('bottom').tickPadding(5);
    yAxis.orient('left');
    x2Axis.orient('bottom').tickPadding(5);
    y2Axis.orient('left');

    tooltip.valueFormatter(function(d, i) {
        return yAxis.tickFormat()(d, i);
    }).headerFormatter(function(d, i) {
        return xAxis.tickFormat()(d, i);
    });

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = nv.utils.availableWidth(width, container, margin),
                availableHeight1 = nv.utils.availableHeight(height, container, margin) - height2,
                availableHeight2 = height2 - margin2.top - margin2.bottom;

            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                nv.utils.noData(chart, container)
                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();
            x2 = lines2.xScale();
            y2 = lines2.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-legendWrap');

            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
            focusEnter.append('g').attr('class', 'nv-x nv-axis');
            focusEnter.append('g').attr('class', 'nv-y nv-axis');
            focusEnter.append('g').attr('class', 'nv-linesWrap');
            focusEnter.append('g').attr('class', 'nv-interactive');

            var contextEnter = gEnter.append('g').attr('class', 'nv-context');
            contextEnter.append('g').attr('class', 'nv-x nv-axis');
            contextEnter.append('g').attr('class', 'nv-y nv-axis');
            contextEnter.append('g').attr('class', 'nv-linesWrap');
            contextEnter.append('g').attr('class', 'nv-brushBackground');
            contextEnter.append('g').attr('class', 'nv-x nv-brush');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight1 = nv.utils.availableHeight(height, container, margin) - height2;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            
            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight1)
                    .margin({left:margin.left, top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            // Main Chart Component(s)
            lines
                .width(availableWidth)
                .height(availableHeight1)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            lines2
                .defined(lines.defined())
                .width(availableWidth)
                .height(availableHeight2)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            g.select('.nv-context')
                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')')

            var contextLinesWrap = g.select('.nv-context .nv-linesWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            d3.transition(contextLinesWrap).call(lines2);

            // Setup Main (Focus) Axes
            xAxis
                .scale(x)
                ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight1, 0);

            yAxis
                .scale(y)
                ._ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                .tickSize( -availableWidth, 0);

            g.select('.nv-focus .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + availableHeight1 + ')');

            // Setup Brush
            brush
                .x(x2)
                .on('brush', function() {
                    onBrush();
                });

            if (brushExtent) brush.extent(brushExtent);

            var brushBG = g.select('.nv-brushBackground').selectAll('g')
                .data([brushExtent || brush.extent()])

            var brushBGenter = brushBG.enter()
                .append('g');

            brushBGenter.append('rect')
                .attr('class', 'left')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            brushBGenter.append('rect')
                .attr('class', 'right')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            var gBrush = g.select('.nv-x.nv-brush')
                .call(brush);
            gBrush.selectAll('rect')
                .attr('height', availableHeight2);
            gBrush.selectAll('.resize').append('path').attr('d', resizePath);

            onBrush();

            // Setup Secondary (Context) Axes
            x2Axis
                .scale(x2)
                ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight2, 0);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');
            d3.transition(g.select('.nv-context .nv-x.nv-axis'))
                .call(x2Axis);

            y2Axis
                .scale(y2)
                ._ticks( nv.utils.calcTicksY(availableHeight2/36, data) )
                .tickSize( -availableWidth, 0);

            d3.transition(g.select('.nv-context .nv-y.nv-axis'))
                .call(y2Axis);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                lines.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                            var extent = brush.empty() ? x2.domain() : brush.extent();
                            var currentValues = series.values.filter(function(d,i) {
                            return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                        });
 
                        pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, lines.x());
                        var point = currentValues[pointIndex];
                        var pointYValue = chart.y()(point, pointIndex);
                        if (pointYValue != null) {
                            lines.highlightPoint(i, pointIndex, true);
                        }
                        if (point === undefined) return;
                        if (singlePoint === undefined) singlePoint = point;
                        if (pointXLocation === undefined) pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex)
                        });
                    });
                //Highlight the tooltip entry based on which point the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                    var threshold = 0.03 * domainExtent;
                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                    if (indexToHighlight !== null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                interactiveLayer.tooltip
                    .position({left: e.mouseX + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .valueFormatter(function(d,i) {
                        return d == null ? "N/A" : yAxis.tickFormat()(d);
                    })
                    .data({
                        value: xValue,
                        index: pointIndex,
                        series: allData
                    })();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                lines.clearHighlights();
            });

            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                }
                chart.update();
            });

            //============================================================
            // Functions
            //------------------------------------------------------------

            // Taken from crossfilter (http://square.github.com/crossfilter/)
            function resizePath(d) {
                var e = +(d == 'e'),
                    x = e ? 1 : -1,
                    y = availableHeight2 / 3;
                return 'M' + (.5 * x) + ',' + y
                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                    + 'V' + (2 * y - 6)
                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                    + 'Z'
                    + 'M' + (2.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8)
                    + 'M' + (4.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8);
            }


            function updateBrushBG() {
                if (!brush.empty()) brush.extent(brushExtent);
                brushBG
                    .data([brush.empty() ? x2.domain() : brushExtent])
                    .each(function(d,i) {
                        var leftWidth = x2(d[0]) - x.range()[0],
                            rightWidth = availableWidth - x2(d[1]);
                        d3.select(this).select('.left')
                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);

                        d3.select(this).select('.right')
                            .attr('x', x2(d[1]))
                            .attr('width', rightWidth < 0 ? 0 : rightWidth);
                    });
            }


            function onBrush() {
                brushExtent = brush.empty() ? null : brush.extent();
                var extent = brush.empty() ? x2.domain() : brush.extent();

                //The brush extent cannot be less than one.  If it is, don't update the line chart.
                if (Math.abs(extent[0] - extent[1]) <= 1) {
                    return;
                }

                dispatch.brush({extent: extent, brush: brush});


                updateBrushBG();

                // Update Main (Focus)
                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                    .datum(
                    data
                        .filter(function(d) { return !d.disabled })
                        .map(function(d,i) {
                            return {
                                key: d.key,
                                area: d.area,
                                values: d.values.filter(function(d,i) {
                                    return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                })
                            }
                        })
                );
                focusLinesWrap.transition().duration(transitionDuration).call(lines);


                // Update Main (Focus) Axes
                g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration)
                    .call(xAxis);
                g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration)
                    .call(yAxis);


// INSEOK'S CODE

                leftRange = Math.floor(extent[0]);
                rightRange = Math.floor(extent[1]);
                if (alreadyDrawing == 0) {
                  alreadyDrawing = 1;
                  updatedRange(leftRange, rightRange);
                }
                alreadyDrawing = 0;

            }
        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(evt) {
        tooltip.data(evt).position(evt.pos).hidden(false);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(evt) {
        tooltip.hidden(true)
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.legend = legend;
    chart.lines = lines;
    chart.lines2 = lines2;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.x2Axis = x2Axis;
    chart.y2Axis = y2Axis;
    chart.interactiveLayer = interactiveLayer;
    chart.tooltip = tooltip;

    chart.leftRange = leftRange;
    chart.rightRange = rightRange;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        focusHeight:     {get: function(){return height2;}, set: function(_){height2=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        brushExtent: {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // deprecated options
        tooltips:    {get: function(){return tooltip.enabled();}, set: function(_){
            // deprecated after 1.7.1
            nv.deprecated('tooltips', 'use chart.tooltip.enabled() instead');
            tooltip.enabled(!!_);
        }},
        tooltipContent:    {get: function(){return tooltip.contentGenerator();}, set: function(_){
            // deprecated after 1.7.1
            nv.deprecated('tooltipContent', 'use chart.tooltip.contentGenerator() instead');
            tooltip.contentGenerator(_);
        }},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        focusMargin: {get: function(){return margin2;}, set: function(_){
            margin2.top    = _.top    !== undefined ? _.top    : margin2.top;
            margin2.right  = _.right  !== undefined ? _.right  : margin2.right;
            margin2.bottom = _.bottom !== undefined ? _.bottom : margin2.bottom;
            margin2.left   = _.left   !== undefined ? _.left   : margin2.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            // line color is handled above?
        }},
        interpolate: {get: function(){return lines.interpolate();}, set: function(_){
            lines.interpolate(_);
            lines2.interpolate(_);
        }},
        xTickFormat: {get: function(){return xAxis.tickFormat();}, set: function(_){
            xAxis.tickFormat(_);
            x2Axis.tickFormat(_);
        }},
        yTickFormat: {get: function(){return yAxis.tickFormat();}, set: function(_){
            yAxis.tickFormat(_);
            y2Axis.tickFormat(_);
        }},
        duration:    {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration=_;
            yAxis.duration(transitionDuration);
            y2Axis.duration(transitionDuration);
            xAxis.duration(transitionDuration);
            x2Axis.duration(transitionDuration);
        }},
        x: {get: function(){return lines.x();}, set: function(_){
            lines.x(_);
            lines2.x(_);
        }},
        y: {get: function(){return lines.y();}, set: function(_){
            lines.y(_);
            lines2.y(_);
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (useInteractiveGuideline) {
                lines.interactive(false);
                lines.useVoronoi(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};

var rawObjects = null;
var rawStrains = [];

function contains(array, item) {
    for (var i = 0; i < array.length; i++) {
        if (array[i] === item) {
            return true;
        }
    }
    return false
}

function renderCSVDropdown(csv) {
        var dropdown = $('select#strains');
        for(var i = 0; i < csv.length; i++) {
            var record = csv[i];
            if (!contains(rawStrains, record["PFGE-XbaI-pattern"])) {
                rawStrains.push(record["PFGE-XbaI-pattern"]);
                var entry = $('<option>').attr('value', record["PFGE-XbaI-pattern"]).html(record["PFGE-XbaI-pattern"]);
                dropdown.append(entry);
            }
        }

        // starts the dropdown as blank
        $('#strains').prop("selectedIndex", -1);
};

function popDropdown() {
    var csv_path = "EC_data2014_v2.csv";
    $.get(csv_path, function(data) {
        rawObjects = $.csv.toObjects(data);
        renderCSVDropdown(rawObjects);
    })};

popDropdown();

function selected(index) {
    // console.log("selected " + rawObjects[index]["PFGE-XbaI-pattern"]);
}
    </script>
