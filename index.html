<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <!-- Import js here -->
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script src="https://cdn.rawgit.com/novus/nvd3/v1.8.1/build/nv.d3.min.js"></script>
  <script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
    <script src="js/jquery.csv-0.71.min.js"></script>
  
  <link rel="stylesheet" href="https://cdn.rawgit.com/novus/nvd3/v1.8.1/build/nv.d3.min.css" rel="stylesheet">
<!--link rel="stylesheet" href="libs/bootstrap.min.css"-->
		<link rel="stylesheet" href="sidebars.css">
		<!--link rel="stylesheet" href="demos.css"-->
  <!-- Style here -->
  <link rel="stylesheet" href="index.css">
</head>

<!-- Main code/website goes here -->
<body>
  <!-- Make sure to seperate necessary code and imports for easier readability -->
  <script>
  /*!
 * Slidebars - A jQuery framework for off-canvas menus and sidebars.
 * Version: 2.0 Beta 11
 * Url: http://plugins.adchsm.me/slidebars/
 * Author: Adam Charles Smith
 * Author url: http://www.adchsm.com/
 * License: GPL General Pubic License v2.0
 * License url: http://www.gnu.org/licenses/gpl-2.0.html
 */

var slidebars = function () {
	
	/**
	 * Setup
	 */
	
	// Cache all canvas elements
	var canvas = $( '[canvas]' ),
	
	// Instances of Slidebars
	offCanvas = {},
	
	// Variables, permitted sides, styles and transitions
	initialized = false,
	registered = false,
	sides = [ 'top', 'right', 'bottom', 'left' ],
	styles = [ 'reveal', 'push', 'overlay' ],

	// Functions
	registerSlidebar = function ( id, side, style, element ) {
		// Check to see if the Slidebar already exists
		if ( offCanvas.hasOwnProperty( id ) ) {
			throw "Error attempting to register Slidebar, a Slidebar with ID '" + id + "' already exists.";
		}
		
		// Register the Slidebar
		offCanvas[ id ] = {
			'id': id,
			'side': side,
			'style': style,
			'element': element,
			'active': false
		};
	},
	getAnimationProperties = function ( id ) {
		// Set variables
		var elements = $(),
		amount = '0px, 0px',
		duration = parseFloat( offCanvas[ id ].element.css( 'transitionDuration' ), 10 ) * 1000;
		
		// Elements to animate
		if ( offCanvas[ id ].style === 'reveal' || offCanvas[ id ].style === 'push' ) {
			elements = elements.add( canvas );
		}
		
		if ( offCanvas[ id ].style === 'push' || offCanvas[ id ].style === 'overlay' ) {
			elements = elements.add( offCanvas[ id ].element );
		}
		
		// Amount to animate
		if ( offCanvas[ id ].active ) {
			if ( offCanvas[ id ].side === 'top' ) {
				amount = '0px, ' + offCanvas[ id ].element.css( 'height' );
			} else if ( offCanvas[ id ].side === 'right' ) {
				amount = '-' + offCanvas[ id ].element.css( 'width' ) + ', 0px';
			} else if ( offCanvas[ id ].side === 'bottom' ) {
				amount = '0px, -' + offCanvas[ id ].element.css( 'height' );
			} else if ( offCanvas[ id ].side === 'left' ) {
				amount = offCanvas[ id ].element.css( 'width' ) + ', 0px';
			}
		}
		
		// Return animation properties
		return { 'elements': elements, 'amount': amount, 'duration': duration };
	};
	
	/**
	 * Initialize
	 */
	
	this.init = function ( callback ) {
		// Check Slidebars hasn't been initialized
		if ( initialized ) {
			throw 'You have already initialized Slidebars.';
		}
		
		// Loop through and register Slidebars
		if ( ! registered ) {
			$( '[off-canvas]' ).each( function () {
				// Get the Slidebar parameters
				var parameters = $( this ).attr( 'off-canvas' ).split( ' ', 3 );
				
				// Make sure a valid id, side and style are specified
				if ( parameters[ 0 ] && sides.indexOf( parameters[ 1 ] ) !== -1 && styles.indexOf( parameters[ 2 ] ) !== -1 ) {
					// Register Slidebar
					registerSlidebar( parameters[ 0 ], parameters[ 1 ], parameters[ 2 ], $( this ) );
				} else {
					throw "Error attempting to register Slidebar, please specifiy a valid space separated 'id side style'.";
				}
			} );
			
			// Set registered variable
			registered = true;
		}
		
		// Set init variable
		initialized = true;
		
		// Set CSS
		this.css();
		
		// Trigger event
		$( events ).trigger( 'init' );
		
		// Run callback
		if ( typeof callback === 'function' ) {
			callback();
		}
	};
	
	this.exit = function ( callback ) {
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// Exit
		var exit = function () {
			// Set init variable
			initialized = false;
			
			// Trigger event
			$( events ).trigger( 'exit' );
			
			// Run callback
			if ( typeof callback === 'function' ) {
				callback();
			}
		};
		
		// Call exit, close open Slidebar if active
		if ( this.active( 'slidebar' ) ) {
			this.close( exit );
		} else {
			exit();
		}
	};
	
	/**
	 * CSS
	 */
	
	this.css = function ( callback ) {
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// Loop through Slidebars to set negative margins
		for ( var id in offCanvas ) {
			// Check Slidebar has the correct id
			if ( offCanvas.hasOwnProperty( id ) ) {
				// Calculate offset
				var offset;
				
				if ( offCanvas[ id ].side === 'top' || offCanvas[ id ].side === 'bottom' ) {
					offset = offCanvas[ id ].element.css( 'height' );
				} else {
					offset = offCanvas[ id ].element.css( 'width' );
				}
				
				// Push and overlay style
				if ( offCanvas[ id ].style === 'push' || offCanvas[ id ].style === 'overlay' ) {
					offCanvas[ id ].element.css( 'margin-' + offCanvas[ id ].side, '-' + offset );
				}
			}
		}
		
		// Reposition open Slidebars
		if ( this.active( 'slidebar' ) ) {
			this.open( this.active( 'slidebar' ) );
		}
		
		// Trigger event
		$( events ).trigger( 'css' );
		
		// Run callback
		if ( typeof callback === 'function' ) {
			callback();
		}
	};
	
	/**
	 * Controls
	 */
	 
	this.open = function ( id, callback ) {
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// If no id was passed, throw error
		if ( ! id ) {
			throw "Error trying to open Slidebar, you must specify an ID.";
		}
		
		// Check to see if the Slidebar exists
		if ( ! offCanvas.hasOwnProperty( id ) ) {
			throw "Error trying to open Slidebar, there is no Slidebar with ID '" + id + "'.";
		}
		
		// Open
		var open = function () {
			// Set active state to true
			offCanvas[ id ].active = true;
			
			// Display the Slidebar
			offCanvas[ id ].element.css( 'display', 'block' );
			
			// Trigger event
			$( events ).trigger( 'opening', [ offCanvas[ id ].id ] );
			
			// Get animation properties
			var animationProperties = getAnimationProperties( id );
			
			// Apply css			
			animationProperties.elements.css( {
				'transition-duration': animationProperties.duration + 'ms',
				'transform': 'translate(' + animationProperties.amount + ')'
			} );
			
			// Transition completed
			setTimeout( function () {
				// Trigger event
				$( events ).trigger( 'opened', [ offCanvas[ id ].id ] );
				
				// Run callback
				if ( typeof callback === 'function' ) {
					callback();
				}
			}, animationProperties.duration );
		};
		
		// Call open, close open Slidebar if active
		if ( this.active( 'slidebar' ) && this.active( 'slidebar' ) !== id ) {
			this.close( open );
		} else {
			open();
		}
	};
	
	this.close = function ( id, callback ) {
		// Shift callback arguments
		if ( typeof id === 'function' ) {
			callback = id;
			id = null;
		}
		
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// Check to see if the Slidebar exists
		if ( id && ! offCanvas.hasOwnProperty( id ) ) {
			throw "Error trying to close Slidebar, there is no Slidebar with ID '" + id + "'.";
		}
		
		// If no id was passed, check to see if any Slidebar is open
		if ( ! id ) {
			// Loop through Slidebars to find active one
			for ( var key in offCanvas ) {
				// Check Slidebar has the correct id
				if ( offCanvas.hasOwnProperty( key ) ) {
					// If it's active, set id
					if ( offCanvas[ key ].active ) {
						id = key;
						break;
					}
				}
			}
		}
		
		// Close a Slidebar
		if ( id && offCanvas[ id ].active ) {
			// Set active state to false
			offCanvas[ id ].active = false;
			
			// Trigger event
			$( events ).trigger( 'closing', [ offCanvas[ id ].id ] );
			
			// Get animation properties
			var animationProperties = getAnimationProperties( id );
			
			// Apply css
			animationProperties.elements.css( 'transform', '' );
			
			// Transition completetion
			setTimeout( function () {
				// Remove transition duration
				animationProperties.elements.css( 'transition-duration', '' );
				
				// Hide the Slidebar
				offCanvas[ id ].element.css( 'display', 'none' );
				
				// Trigger event
				$( events ).trigger( 'closed', [ offCanvas[ id ].id ] );
				
				// Run callback
				if ( typeof callback === 'function' ) {
					callback();
				}
			}, animationProperties.duration );
		}
	};
	
	this.toggle = function ( id, callback ) {
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// If no id was passed, throw error
		if ( ! id ) {
			throw "Error trying to toggle Slidebar, you must specify an ID.";
		}
		
		// Check to see if the Slidebar exists
		if ( ! offCanvas.hasOwnProperty( id ) ) {
			throw "Error trying to toggle Slidebar, there is no Slidebar with ID '" + id + "'.";
		}
		
		// Check its state
		if ( offCanvas[ id ].active ) {
			// It's open, close it
			this.close( id, function () {
				// Run callback
				if ( typeof callback === 'function' ) {
					callback();
				}
			} );
		} else {
			// It's closed, open it
			this.open( id, function () {
				// Run callback
				if ( typeof callback === 'function' ) {
					callback();
				}
			} );
		}
	};
	
	/**
	 * State
	 */
	 
	this.active = function ( query, callback ) {
		// Shift callback arguments
		if ( typeof query === 'function' ) {
			callback = query;
			query = null;
		}
		
		// Variable to return
		var active = false;
		
		// Check init
		if ( ! query ) {
			active = initialized;
		} else
		
		// Check all Slidebars
		if ( query === 'slidebar' ) {
			// Check Slidebars has been initialized
			if ( ! initialized ) {
				throw 'You need to initialize Slidebars first.';
			}
			
			// Loop through Slidebars
			for ( var id in offCanvas ) {
				// Check Slidebar has the correct id
				if ( offCanvas.hasOwnProperty( id ) ) {
					// Check if it's active
					if ( offCanvas[ id ].active ) {
						// Set the active id
						active = offCanvas[ id ].id;
						break;
					}
				}
			}
		} else
		
		// Check specific id
		{
			// Check Slidebars has been initialized
			if ( ! initialized ) {
				throw 'You need to initialize Slidebars first.';
			}
			
			// Check to see if the Slidebar exists
			if ( ! offCanvas.hasOwnProperty( query ) ) {
				throw "Error retrieving state of Slidebar, there is no Slidebar with ID '" + query + "'.";
			}
			
			// Set the active state
			active = offCanvas[ query ].active;
		}
		
		// Run callback
		if ( typeof callback === 'function' ) {
			callback();
		}
		
		// Return
		return active;
	};
	
	/**
	 * Manage
	 */
	
	this.create = function ( id, side, style, content, callback ) {
		// Shift callback arguments
		if ( typeof content === 'function' ) {
			callback = content;
			content = null;
		}
		
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// Make sure a valid id, side and style are specified
		if ( id && sides.indexOf( side ) !== -1 && styles.indexOf( style ) !== -1 ) {
			// Check to see if the Slidebar exists
			if ( offCanvas.hasOwnProperty( id ) ) {
				throw "Error attempting to create Slidebar, a Slidebar with ID '" + id + "' already exists.";
			}
			
			// Create new element
			$( '<div id="' + id + '" off-canvas="' + id + ' ' + side + ' ' + style + '"></div>' ).appendTo( 'body' );
			
			// Add content to the Slidebar
			if ( content ) {
				$( '#' + id ).html( content );
			}
			
			// Register the Slidebar
			registerSlidebar( id, side, style, $( '#' + id ) );
			
			// Reset CSS
			this.css();
			
			// Trigger event
			$( events ).trigger( 'created', [ offCanvas[ id ].id ] );
			
			// Run callback
			if ( typeof callback === 'function' ) {
				callback();
			}
		} else {
			throw "Error attempting to create Slidebar, please specifiy a valid space separated 'id side style'.";
		}
	};
	
	this.destroy = function ( id, callback ) {
		// Check Slidebars has been initialized
		if ( ! initialized ) {
			throw 'You need to initialize Slidebars first.';
		}
		
		// If no id was passed, throw error
		if ( ! id ) {
			throw "Error trying to destroy Slidebar, you must specify an ID.";
		}
		
		// Check to see if the Slidebar exists
		if ( ! offCanvas.hasOwnProperty( id ) ) {
			throw "Error trying to destroy Slidebar, there is no Slidebar with ID '" + id + "'.";
		}
		
		// Destruction
		var destroy = function () {
			// Trigger event
			$( events ).trigger( 'destroyed', [ offCanvas[ id ].id ] );
			
			// Remove the element
			offCanvas[ id ].element.remove();
			
			// Remove Slidebar from instances
			delete offCanvas[ id ];
			
			// Run callback
			if ( typeof callback === 'function' ) {
				callback();
			}
		};
		
		// Call destroy, close open Slidebar if active
		if ( offCanvas[ id ].active ) {
			this.close( id, destroy );
		} else {
			destroy();
		}
	};
	
	/**
	 * Events
	 */
	
	// Public
	this.events = {};
	
	// Private
	var events = this.events;
};
  </script>
  <!-- Seperating by div's to clean up code further -->
  <div id='header'>
    <div align='center' id='title'>
		
      <h1 class='Arial'> 2014 Reported Escherichia coli O157 </h1>
    </div>
  </div>

  <div id='filterPanel'>


    <div id='setrange'>
      <input type="text" id="leftRange" value="First day"/>
      <input type="text" id="rightRange" value="Second day"/>
      <input type="button" id="changerange" value="Change"/>
    </div>
    <div id='animate'>
      <input type="text" id="daysrange" value="Date increment"/>
      <input type="text" id="timems" value="Time in ms"/>
      <input type="button" id="animate" value="Animate"/>
      <div canvas="container" class="close-any">
			
			
		</div>
		
		<div id='leftpanel' off-canvas="sb-1 left reveal">
		</div>      
    </div>
  </div>

  <div id="detailsPanel">
    <p align="center"> Total Count </p>
    <div id='totalCount'>

    </div>
    <p align="center"> Selected Date Range </p>
    <div id="dateRange">

    </div>
    <p align="center"> Recorded Outbreaks </p>
    <div id="outbreaks">

    </div>
  </div>

  <div id='map'>
    <div id='choropleth'>

    </div>
    <div id ='legend'>

    </div>
  </div>

  <div id='histogram'>
    <svg></svg>
  </div>


</body>
         <script>
/**
 * Renders the map
 */

var countySelected = 0;

var countiesFilename = "us_counties_v2.json";

var width = 1399, height = 620;
var histogram = null;
  
var projection = d3.geo.albersUsa();

var path = d3.geo.path()
    .projection(projection);

var zoom = d3.behavior.zoom()
    .translate([0,0])
    .scale(1)
    .scaleExtent([1,8])
    .on("zoom", zoomed)

var mapSvg = d3.select("#choropleth").append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(zoom);

var vector = mapSvg.append("g");

var legendSvg = d3.select('#choropleth').append("svg")
    .attr("width", width)
    .attr("height", 50)
    .attr("class", "legend");


    for (var i = 0; i < 9; i++) {
      legendSvg.append("rect")
        .attr("width", 100)
        .attr("height", 15)
        .attr("x", 300 + i * 100)
        .attr("y", 10)
        .attr("class", "q" + i + "-9");
    }


var aggrByCounty = [];

var sidebarOpen = false;

// Create a new instance of Slidebars
var controller = new slidebars();
					
// Initialize Slidebars
controller.init();
					
function handleDate(date) {
  var str = date.split("/");
  var monthDays = 0, 
      dayDays = parseInt(str[1]),
      x = parseInt(str[0]);

  if (x >= 1)
    monthDays += 0;
  if (x >= 2)
    monthDays += 31;
  if (x >= 3)
    monthDays += 28;
  if (x >= 4)
    monthDays += 31;
  if (x >= 5)
    monthDays += 30;
  if (x >= 6)
    monthDays += 31;
  if (x >= 7)
    monthDays += 30;
  if (x >= 8)
    monthDays += 31;
  if (x >= 9)
    monthDays += 31;
  if (x >= 10)
    monthDays += 30;
  if (x >= 11)
    monthDays += 31;
  if (x >= 12)
    monthDays += 30;

  return monthDays + dayDays - 1;
}

function handleNameDate(number) {
  var month = "January", day = 0;
  if (number > 31) {
    month = "February";
    number -= 31;
  }
  if (number > 28) {
    month = "March";
    number -= 28;
  }
  if (number > 31) {
    month = "April";
    number -= 31;
  }
  if (number > 30) {
    month = "May";
    number -= 30;
  }
  if (number > 31) {
    month = "June";
    number -= 31;
  }
  if (number > 30) {
    month = "July";
    number -= 30;
  }
  if (number > 31) {
    month = "August";
    number -= 31;
  }
  if (number > 31) {
    month = "September";
    number -= 31;
  }
  if (number > 30) {
    month = "October";
    number -= 30;
  }
  if (number > 31) {
    month = "November";
    number -= 31;
  }
  if (number > 30) {
    month = "December";
    number -= 30;
  }
  day = number;
  return month + " " + day;
}

d3.csv("EC_data2014_v2.csv", function(data) {  
  /* Associative array mapping counties to an array of disease incidences
   * of form [city -> [incidences]] 
   */

        
        var totalCount = 0;
  

      var aggrByDate = [];
      
      function county(GEOID, SourceCounty, SourceState ) {
    this.GEOID = GEOID;
    this.SourceCounty = SourceCounty;
    this.SourceState = SourceState;
    this.Occurrences = [];
  }
  
  function date (UploadDate) {
    this.UploadDate = UploadDate;
    this.Occurrences = [];
  }

  for (i = 0; i < 365; i++) {
    aggrByDate.push(new date(i));
  }
  
       data.forEach(function(incidence) {
    totalCount += 1;

    // Initialize occurrence object
    var occurrence = {
      UploadDate : incidence.UploadDate,  
      PFGEBlnIpattern : incidence["PFGE-BlnI-pattern"],
      PFGEXbaIpattern : incidence["PFGE-XbaI-pattern"]
    };

    var i = parseInt(incidence.GEOID);
    var j = handleDate(incidence.UploadDate);

    if (aggrByCounty[i] == null) {
      aggrByCounty[i] = new county(i, incidence.SourceCounty, incidence.SourceState);
    }
    aggrByCounty[i].Occurrences.push(occurrence);
    aggrByDate[j].Occurrences.push(occurrence);
  });



  // Draw histogram
  var data = function() {
    return d3.range(1).map(function() {
      return aggrByDate.map(stream_index);
    }).map(function(data, i) {
      return {
        key: 'Stream' + i,
        values: data
      };
    });
  }
  
  function stream_index(d, i) {
    return {x: i + 1, y: Math.max(0, d.Occurrences.length)};
  }

  nv.addGraph(function() {
    var chart = nv.models.lineWithFocusChart();
    
    chart.xAxis
      .tickFormat(d3.format(',f'))
      .axisLabel("Days");
    
    chart.yAxis
      .tickFormat(d3.format(',f'))
      .axisLabel("# of Occurrences");
    
    chart.y2Axis
      .tickFormat(d3.format(',f'));
    
    chart.showLegend(false);
    
    d3.select('#histogram svg')
      .datum(data())
      .transition().duration(100)
      .call(chart);

    histogram = chart;
    return chart;
  });
        
        
        d3.json(countiesFilename, function(error, us) {
    // Modify individual counties
    vector.selectAll(".counties")
      .data(topojson.feature(us, us.objects.counties).features)
      .enter().append("path")
      .attr("id", "county-boundary")
      .attr("class", function(d) {
        var i = d.id;
        var numOccurrences = 0;
        if (aggrByCounty[i] == null) 
          numOccurrences = 0;
        else{
          for (var j = 0; j < aggrByCounty[i].Occurrences.length; j++) {
            numOccurrences += 1;
          }
        }
        return "q" + Math.floor((numOccurrences / 35) * 9) + "-9";
      })
      .attr("d", path)
      .style({'stroke-width': "0.2", 'stroke': "rgba(0, 0, 0, 0.4)"})
      // Add tooltips
      .on("click", function(d) {
			
			var panelText = "";
			var id = aggrByCounty[d.id];
			console.log(id);
				  if (!(id == null)) {
					  panelText = "<b>" + id.SourceCounty + ", " + id.SourceState + "</b> has infected population of "
						+ id.Occurrences.length + " with the following strains: ";
					  id.Occurrences.forEach(function(occurrence) {
						  panelText += occurrence.PFGEXbaIpattern + "<br>";
					  });
					  
				  } 
				  document.getElementById('leftpanel').innerHTML = panelText;
						// Toggle Slidebar
					if (sidebarOpen) {
						//console.log("sidebar open. closing...");
						controller.close( 'sb-1' );
						sidebarOpen = false;
					} else {
						//console.log("sidebar closed. opening...");
						controller.open( 'sb-1' );
						sidebarOpen = true;
					}
			  })
      .call(d3.helper.tooltip(function(d) {
          var i = d.id;
          if (aggrByCounty[i] == null) {
            return "No reported incidences"; 
          }
          else
            return "<b>"+ aggrByCounty[i].SourceCounty 
              + " County</b> Infected: " 
              + aggrByCounty[i].Occurrences.length;
      }));

    // Modify state borders
    vector.append("path")
      .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
      .attr("class", "states")
      .attr("d", path);
  });

  // Label legend
  for (var i = 0; i < 10; i++) {
    legendSvg.append("text")
      .attr("id", "ll" + i)
      .attr("x", 295 + i * 100)
      .attr("y", 35);

    document.getElementById("ll" + i).innerHTML = Math.floor(35/9 * i);
  }

  // Label details panel
  d3.select('#totalCount')
    .append("text")
    .attr("id", "tc");

  document.getElementById("tc").innerHTML = totalCount;

  d3.select('#dateRange')
    .append("text")
    .attr("id", "dr");

  document.getElementById("dr").innerHTML = "Jan 1 ~ Dec 31";

  d3.select('#outbreaks')
    .append("text")
    .attr("id", "ob");

  document.getElementById("ob").innerHTML = " ";
});

      var mouseDown = 0;
document.body.onmousedown = function() { 
  ++mouseDown;
}
document.body.onmouseup = function() {
  --mouseDown;
}

function zoomed() {
  vector.attr("transform", "translate(" + d3.event.translate 
    + ")scale(" + d3.event.scale + ")");
  vector.select(".states").style("stroke-width", 1 / d3.event.scale + "px");
  vector.select("#county-boundary").style("stroke-width", 1 / d3.event.scale + "px");
}

var rangedOutbreakCount = 0;
function updatedRange(leftRange, rightRange) {
  d3.json(countiesFilename, function(error, us) {
  document.getElementById("dr").innerHTML = handleNameDate(leftRange) + "\n ~ \n"  + handleNameDate(rightRange);
  rangedOutbreakCount = 0;
    // Modify individual counties
    d3.selectAll('#county-boundary')
      .attr("class", function(d) {
        var i = d.id;
        var numOccurrences = 0;
        if (aggrByCounty[i] == null) 
          numOccurrences = 0;
        else{
          for (var j = 0; j < aggrByCounty[i].Occurrences.length; j++) {
            var numDays = handleDate(aggrByCounty[i].Occurrences[j].UploadDate);
            if (numDays >= leftRange && numDays <= rightRange){
              numOccurrences++;
              rangedOutbreakCount++;
            }

          }
        }
        return "q" + Math.floor((numOccurrences / 35) * 9) + "-9";
      })
      .attr("d", path)
      .style({'stroke-width': "0.2", 'stroke': "rgba(0, 0, 0, 0.4)"})
      // Add tooltips
      .call(d3.helper.tooltip(function(d) {
          var i = d.id;
          if (aggrByCounty[i] == null) {
            return "No reported incidences"; 
          }
          else{
            var numOccurrences = 0;
            for (var j = 0; j < aggrByCounty[i].Occurrences.length; j++) {
            var numDays = handleDate(aggrByCounty[i].Occurrences[j].UploadDate);
            if (numDays >= leftRange && numDays <= rightRange){
              numOccurrences++;
            }
          }
            return "<b>"+ aggrByCounty[i].SourceCounty 
              + " County</b> Infected: " 
              + numOccurrences;
          }
      }));

  });
  document.getElementById("ob").innerHTML = "" +  rangedOutbreakCount;
}

      d3.helper = {};

      d3.helper.tooltip = function(accessor){
          return function(selection){
              var tooltipDiv;
              var bodyNode = d3.select('body').node();
              selection.on("mouseover", function(d, i){
                  // Clean up lost tooltips
                  d3.select('body').selectAll('div.tooltip').remove();
                  // Append tooltip
                  tooltipDiv = d3.select('body').append('div').attr('class', 'tooltip');
                  var absoluteMousePos = d3.mouse(bodyNode);
                  tooltipDiv.style('left', (absoluteMousePos[0] + 10)+'px')
                      .style('top', (absoluteMousePos[1] - 15)+'px')
                      .style('position', 'absolute') 
                      .style('z-index', 1001);
                  // Add text using the accessor function
                  var tooltipText = accessor(d, i) || '';
                  console.log("hover tip: " + tooltipText);
                  if (tooltipText == "") tooltipDiv.remove();
              })
              .on('mousemove', function(d, i) {
                  //Move tooltip
                  var absoluteMousePos = d3.mouse(bodyNode);
                  tooltipDiv.style('left', (absoluteMousePos[0] + 10)+'px')
                      .style('top', (absoluteMousePos[1] - 15)+'px');
                  var tooltipText = accessor(d, i) || '';
                  console.log("move tip: " + tooltipText);
                  if (tooltipText == "") {
					  tooltipDiv.remove();
				  }
                  else tooltipDiv.html(tooltipText);
              })
              .on("mouseout", function(d, i){
                  // Remove tooltip
                  tooltipDiv.remove();
              })

          };
      };

function setRange(leftRange, rightRange) {
    histogram.brushExtent([leftRange,rightRange]).update();
}
function setIntervalRange(left, days, range, ms) {
  if (left + range > 365) setRange(left, 365);
  else setRange(left, left + range );
  left += days;
  console.log(left); 
  if (left >= 365)
    return;
  setTimeout(function() {setIntervalRange(left, days, range, ms);}, ms);
}

$("#changerange").click(function () {
  setRange(parseInt($("#leftRange").val()), parseInt($("#rightRange").val()));
});

$("#animate").click(function () {
  var range = parseInt($("#leftRange").val()) + parseInt($("#rightRange").val())
  var days = parseInt($("#daysrange").val());
  var ms = $("#timems").val();
  var left = 1;
  setIntervalRange(left, days, range, ms);
});

d3.helper = {};

d3.helper.tooltip = function(accessor){
    return function(selection){
        var tooltipDiv;
        var bodyNode = d3.select('body').node();
        selection.on("mouseover", function(d){
            // Clean up lost tooltips
            d3.select('body').selectAll('div.tooltip').remove();
            // Append tooltip
            tooltipDiv = d3.select('body').append('div').attr('class', 'tooltip');
            var absoluteMousePos = d3.mouse(bodyNode);
            tooltipDiv.style('left', (absoluteMousePos[0] + 10)+'px')
                .style('top', (absoluteMousePos[1] - 15)+'px')
                .style('position', 'absolute') 
                .style('z-index', 999999);
            // Add text using the accessor function
            var tooltipText = accessor(d) || '';
        })
        .on('mousemove', function(d) {
            // Move tooltip
            var absoluteMousePos = d3.mouse(bodyNode);
            tooltipDiv.style('left', (absoluteMousePos[0] + 10)+'px')
                .style('top', (absoluteMousePos[1] - 15)+'px');
            var tooltipText = accessor(d) || '';
            tooltipDiv.html(tooltipText);
        })
        .on("mouseout", function(d){
            // Remove tooltip
            tooltipDiv.remove();
        });

    };
};


//=========================================================================================
//  Don't touch below, API stuff
//=========================================================================================

nv.models.lineWithFocusChart = function() {
    "use strict";

    //============================================================
    // Public Variables with Default Settings
    //------------------------------------------------------------

    var lines = nv.models.line()
        , lines2 = nv.models.line()
        , xAxis = nv.models.axis()
        , yAxis = nv.models.axis()
        , x2Axis = nv.models.axis()
        , y2Axis = nv.models.axis()
        , legend = nv.models.legend()
        , brush = d3.svg.brush()
        , tooltip = nv.models.tooltip()
        , interactiveLayer = nv.interactiveGuideline()
        ;

    var margin = {top: 30, right: 30, bottom: 30, left: 60}
        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}
        , color = nv.utils.defaultColor()
        , width = null
        , height = null
        , height2 = 50
        , useInteractiveGuideline = false
        , x
        , y
        , x2
        , y2
        , showLegend = true
        , brushExtent = null
        , noData = null
        , dispatch = d3.dispatch('brush', 'stateChange', 'changeState')
        , transitionDuration = 250
        , state = nv.utils.state()
        , defaultState = null
        ;

    var leftRange = 0
        , rightRange = 0
        ;

    lines.clipEdge(true).duration(0);
    lines2.interactive(false);
    // We don't want any points emitted for the focus chart's scatter graph.
    lines2.pointActive(function(d) { return false });
    xAxis.orient('bottom').tickPadding(5);
    yAxis.orient('left');
    x2Axis.orient('bottom').tickPadding(5);
    y2Axis.orient('left');

    tooltip.valueFormatter(function(d, i) {
        return yAxis.tickFormat()(d, i);
    }).headerFormatter(function(d, i) {
        return xAxis.tickFormat()(d, i);
    });

    //============================================================
    // Private Variables
    //------------------------------------------------------------

    var stateGetter = function(data) {
        return function(){
            return {
                active: data.map(function(d) { return !d.disabled })
            };
        }
    };

    var stateSetter = function(data) {
        return function(state) {
            if (state.active !== undefined)
                data.forEach(function(series,i) {
                    series.disabled = !state.active[i];
                });
        }
    };

    function chart(selection) {
        selection.each(function(data) {
            var container = d3.select(this),
                that = this;
            nv.utils.initSVG(container);
            var availableWidth = nv.utils.availableWidth(width, container, margin),
                availableHeight1 = nv.utils.availableHeight(height, container, margin) - height2,
                availableHeight2 = height2 - margin2.top - margin2.bottom;

            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };
            chart.container = this;

            state
                .setter(stateSetter(data), chart.update)
                .getter(stateGetter(data))
                .update();

            // DEPRECATED set state.disableddisabled
            state.disabled = data.map(function(d) { return !!d.disabled });

            if (!defaultState) {
                var key;
                defaultState = {};
                for (key in state) {
                    if (state[key] instanceof Array)
                        defaultState[key] = state[key].slice(0);
                    else
                        defaultState[key] = state[key];
                }
            }

            // Display No Data message if there's nothing to show.
            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {
                nv.utils.noData(chart, container)
                return chart;
            } else {
                container.selectAll('.nv-noData').remove();
            }

            // Setup Scales
            x = lines.xScale();
            y = lines.yScale();
            x2 = lines2.xScale();
            y2 = lines2.yScale();

            // Setup containers and skeleton of chart
            var wrap = container.selectAll('g.nv-wrap.nv-lineWithFocusChart').data([data]);
            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineWithFocusChart').append('g');
            var g = wrap.select('g');

            gEnter.append('g').attr('class', 'nv-legendWrap');

            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');
            focusEnter.append('g').attr('class', 'nv-x nv-axis');
            focusEnter.append('g').attr('class', 'nv-y nv-axis');
            focusEnter.append('g').attr('class', 'nv-linesWrap');
            focusEnter.append('g').attr('class', 'nv-interactive');

            var contextEnter = gEnter.append('g').attr('class', 'nv-context');
            contextEnter.append('g').attr('class', 'nv-x nv-axis');
            contextEnter.append('g').attr('class', 'nv-y nv-axis');
            contextEnter.append('g').attr('class', 'nv-linesWrap');
            contextEnter.append('g').attr('class', 'nv-brushBackground');
            contextEnter.append('g').attr('class', 'nv-x nv-brush');

            // Legend
            if (showLegend) {
                legend.width(availableWidth);

                g.select('.nv-legendWrap')
                    .datum(data)
                    .call(legend);

                if ( margin.top != legend.height()) {
                    margin.top = legend.height();
                    availableHeight1 = nv.utils.availableHeight(height, container, margin) - height2;
                }

                g.select('.nv-legendWrap')
                    .attr('transform', 'translate(0,' + (-margin.top) +')')
            }

            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

            
            //Set up interactive layer
            if (useInteractiveGuideline) {
                interactiveLayer
                    .width(availableWidth)
                    .height(availableHeight1)
                    .margin({left:margin.left, top:margin.top})
                    .svgContainer(container)
                    .xScale(x);
                wrap.select(".nv-interactive").call(interactiveLayer);
            }

            // Main Chart Component(s)
            lines
                .width(availableWidth)
                .height(availableHeight1)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            lines2
                .defined(lines.defined())
                .width(availableWidth)
                .height(availableHeight2)
                .color(
                data
                    .map(function(d,i) {
                        return d.color || color(d, i);
                    })
                    .filter(function(d,i) {
                        return !data[i].disabled;
                    })
            );

            g.select('.nv-context')
                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')')

            var contextLinesWrap = g.select('.nv-context .nv-linesWrap')
                .datum(data.filter(function(d) { return !d.disabled }))

            d3.transition(contextLinesWrap).call(lines2);

            // Setup Main (Focus) Axes
            xAxis
                .scale(x)
                ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight1, 0);

            yAxis
                .scale(y)
                ._ticks( nv.utils.calcTicksY(availableHeight1/36, data) )
                .tickSize( -availableWidth, 0);

            g.select('.nv-focus .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + availableHeight1 + ')');

            // Setup Brush
            brush
                .x(x2)
                .on('brush', function() {
                    onBrush();
                });

            if (brushExtent) brush.extent(brushExtent);

            var brushBG = g.select('.nv-brushBackground').selectAll('g')
                .data([brushExtent || brush.extent()])

            var brushBGenter = brushBG.enter()
                .append('g');

            brushBGenter.append('rect')
                .attr('class', 'left')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            brushBGenter.append('rect')
                .attr('class', 'right')
                .attr('x', 0)
                .attr('y', 0)
                .attr('height', availableHeight2);

            var gBrush = g.select('.nv-x.nv-brush')
                .call(brush);
            gBrush.selectAll('rect')
                .attr('height', availableHeight2);
            gBrush.selectAll('.resize').append('path').attr('d', resizePath);

            onBrush();

            // Setup Secondary (Context) Axes
            x2Axis
                .scale(x2)
                ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )
                .tickSize(-availableHeight2, 0);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');
            d3.transition(g.select('.nv-context .nv-x.nv-axis'))
                .call(x2Axis);

            y2Axis
                .scale(y2)
                ._ticks( nv.utils.calcTicksY(availableHeight2/36, data) )
                .tickSize( -availableWidth, 0);

            d3.transition(g.select('.nv-context .nv-y.nv-axis'))
                .call(y2Axis);

            g.select('.nv-context .nv-x.nv-axis')
                .attr('transform', 'translate(0,' + y2.range()[0] + ')');

            //============================================================
            // Event Handling/Dispatching (in chart's scope)
            //------------------------------------------------------------

            legend.dispatch.on('stateChange', function(newState) {
                for (var key in newState)
                    state[key] = newState[key];
                dispatch.stateChange(state);
                chart.update();
            });

            interactiveLayer.dispatch.on('elementMousemove', function(e) {
                lines.clearHighlights();
                var singlePoint, pointIndex, pointXLocation, allData = [];
                data
                    .filter(function(series, i) {
                        series.seriesIndex = i;
                        return !series.disabled;
                    })
                    .forEach(function(series,i) {
                            var extent = brush.empty() ? x2.domain() : brush.extent();
                            var currentValues = series.values.filter(function(d,i) {
                            return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                        });
 
                        pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, lines.x());
                        var point = currentValues[pointIndex];
                        var pointYValue = chart.y()(point, pointIndex);
                        if (pointYValue != null) {
                            lines.highlightPoint(i, pointIndex, true);
                        }
                        if (point === undefined) return;
                        if (singlePoint === undefined) singlePoint = point;
                        if (pointXLocation === undefined) pointXLocation = chart.xScale()(chart.x()(point,pointIndex));
                        allData.push({
                            key: series.key,
                            value: chart.y()(point, pointIndex),
                            color: color(series,series.seriesIndex)
                        });
                    });
                //Highlight the tooltip entry based on which point the mouse is closest to.
                if (allData.length > 2) {
                    var yValue = chart.yScale().invert(e.mouseY);
                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);
                    var threshold = 0.03 * domainExtent;
                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);
                    if (indexToHighlight !== null)
                        allData[indexToHighlight].highlight = true;
                }

                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));
                interactiveLayer.tooltip
                    .position({left: e.mouseX + margin.left, top: e.mouseY + margin.top})
                    .chartContainer(that.parentNode)
                    .valueFormatter(function(d,i) {
                        return d == null ? "N/A" : yAxis.tickFormat()(d);
                    })
                    .data({
                        value: xValue,
                        index: pointIndex,
                        series: allData
                    })();

                interactiveLayer.renderGuideLine(pointXLocation);

            });

            interactiveLayer.dispatch.on("elementMouseout",function(e) {
                lines.clearHighlights();
            });

            dispatch.on('changeState', function(e) {
                if (typeof e.disabled !== 'undefined') {
                    data.forEach(function(series,i) {
                        series.disabled = e.disabled[i];
                    });
                }
                chart.update();
            });

            //============================================================
            // Functions
            //------------------------------------------------------------

            // Taken from crossfilter (http://square.github.com/crossfilter/)
            function resizePath(d) {
                var e = +(d == 'e'),
                    x = e ? 1 : -1,
                    y = availableHeight2 / 3;
                return 'M' + (.5 * x) + ',' + y
                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)
                    + 'V' + (2 * y - 6)
                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)
                    + 'Z'
                    + 'M' + (2.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8)
                    + 'M' + (4.5 * x) + ',' + (y + 8)
                    + 'V' + (2 * y - 8);
            }


            function updateBrushBG() {
                if (!brush.empty()) brush.extent(brushExtent);
                brushBG
                    .data([brush.empty() ? x2.domain() : brushExtent])
                    .each(function(d,i) {
                        var leftWidth = x2(d[0]) - x.range()[0],
                            rightWidth = availableWidth - x2(d[1]);
                        d3.select(this).select('.left')
                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);

                        d3.select(this).select('.right')
                            .attr('x', x2(d[1]))
                            .attr('width', rightWidth < 0 ? 0 : rightWidth);
                    });
            }


            function onBrush() {
                brushExtent = brush.empty() ? null : brush.extent();
                var extent = brush.empty() ? x2.domain() : brush.extent();

                //The brush extent cannot be less than one.  If it is, don't update the line chart.
                if (Math.abs(extent[0] - extent[1]) <= 1) {
                    return;
                }

                dispatch.brush({extent: extent, brush: brush});


                updateBrushBG();

                // Update Main (Focus)
                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')
                    .datum(
                    data
                        .filter(function(d) { return !d.disabled })
                        .map(function(d,i) {
                            return {
                                key: d.key,
                                area: d.area,
                                values: d.values.filter(function(d,i) {
                                    return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];
                                })
                            }
                        })
                );
                focusLinesWrap.transition().duration(transitionDuration).call(lines);


                // Update Main (Focus) Axes
                g.select('.nv-focus .nv-x.nv-axis').transition().duration(transitionDuration)
                    .call(xAxis);
                g.select('.nv-focus .nv-y.nv-axis').transition().duration(transitionDuration)
                    .call(yAxis);


// INSEOK'S CODE

                leftRange = Math.floor(extent[0]);
                rightRange = Math.floor(extent[1]);
                updatedRange(leftRange, rightRange);

            }
        });

        return chart;
    }

    //============================================================
    // Event Handling/Dispatching (out of chart's scope)
    //------------------------------------------------------------

    lines.dispatch.on('elementMouseover.tooltip', function(evt) {
        tooltip.data(evt).position(evt.pos).hidden(false);
    });

    lines.dispatch.on('elementMouseout.tooltip', function(evt) {
        tooltip.hidden(true)
    });

    //============================================================
    // Expose Public Variables
    //------------------------------------------------------------

    // expose chart's sub-components
    chart.dispatch = dispatch;
    chart.legend = legend;
    chart.lines = lines;
    chart.lines2 = lines2;
    chart.xAxis = xAxis;
    chart.yAxis = yAxis;
    chart.x2Axis = x2Axis;
    chart.y2Axis = y2Axis;
    chart.interactiveLayer = interactiveLayer;
    chart.tooltip = tooltip;

    chart.leftRange = leftRange;
    chart.rightRange = rightRange;

    chart.options = nv.utils.optionsFunc.bind(chart);

    chart._options = Object.create({}, {
        // simple options, just get/set the necessary values
        width:      {get: function(){return width;}, set: function(_){width=_;}},
        height:     {get: function(){return height;}, set: function(_){height=_;}},
        focusHeight:     {get: function(){return height2;}, set: function(_){height2=_;}},
        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},
        brushExtent: {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},
        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},
        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},

        // deprecated options
        tooltips:    {get: function(){return tooltip.enabled();}, set: function(_){
            // deprecated after 1.7.1
            nv.deprecated('tooltips', 'use chart.tooltip.enabled() instead');
            tooltip.enabled(!!_);
        }},
        tooltipContent:    {get: function(){return tooltip.contentGenerator();}, set: function(_){
            // deprecated after 1.7.1
            nv.deprecated('tooltipContent', 'use chart.tooltip.contentGenerator() instead');
            tooltip.contentGenerator(_);
        }},

        // options that require extra logic in the setter
        margin: {get: function(){return margin;}, set: function(_){
            margin.top    = _.top    !== undefined ? _.top    : margin.top;
            margin.right  = _.right  !== undefined ? _.right  : margin.right;
            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;
            margin.left   = _.left   !== undefined ? _.left   : margin.left;
        }},
        focusMargin: {get: function(){return margin2;}, set: function(_){
            margin2.top    = _.top    !== undefined ? _.top    : margin2.top;
            margin2.right  = _.right  !== undefined ? _.right  : margin2.right;
            margin2.bottom = _.bottom !== undefined ? _.bottom : margin2.bottom;
            margin2.left   = _.left   !== undefined ? _.left   : margin2.left;
        }},
        color:  {get: function(){return color;}, set: function(_){
            color = nv.utils.getColor(_);
            legend.color(color);
            // line color is handled above?
        }},
        interpolate: {get: function(){return lines.interpolate();}, set: function(_){
            lines.interpolate(_);
            lines2.interpolate(_);
        }},
        xTickFormat: {get: function(){return xAxis.tickFormat();}, set: function(_){
            xAxis.tickFormat(_);
            x2Axis.tickFormat(_);
        }},
        yTickFormat: {get: function(){return yAxis.tickFormat();}, set: function(_){
            yAxis.tickFormat(_);
            y2Axis.tickFormat(_);
        }},
        duration:    {get: function(){return transitionDuration;}, set: function(_){
            transitionDuration=_;
            yAxis.duration(transitionDuration);
            y2Axis.duration(transitionDuration);
            xAxis.duration(transitionDuration);
            x2Axis.duration(transitionDuration);
        }},
        x: {get: function(){return lines.x();}, set: function(_){
            lines.x(_);
            lines2.x(_);
        }},
        y: {get: function(){return lines.y();}, set: function(_){
            lines.y(_);
            lines2.y(_);
        }},
        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){
            useInteractiveGuideline = _;
            if (useInteractiveGuideline) {
                lines.interactive(false);
                lines.useVoronoi(false);
            }
        }}
    });

    nv.utils.inheritOptions(chart, lines);
    nv.utils.initOptions(chart);

    return chart;
};

var rawObjects = null;
var rawStrains = [];

function contains(array, item) {
    for (var i = 0; i < array.length; i++) {
        if (array[i] === item) {
            return true;
        }
    }
    return false
}

function renderCSVDropdown(csv) {
        var dropdown = $('select#strains');
        for(var i = 0; i < csv.length; i++) {
            var record = csv[i];
            if (!contains(rawStrains, record["PFGE-XbaI-pattern"])) {
                rawStrains.push(record["PFGE-XbaI-pattern"]);
                var entry = $('<option>').attr('value', record["PFGE-XbaI-pattern"]).html(record["PFGE-XbaI-pattern"]);
                dropdown.append(entry);
            }
        }

        // starts the dropdown as blank
        $('#strains').prop("selectedIndex", -1);
};

function popDropdown() {
    var csv_path = "EC_data2014_v2.csv";
    $.get(csv_path, function(data) {
        rawObjects = $.csv.toObjects(data);
        renderCSVDropdown(rawObjects);
    })};

popDropdown();

function selected(index) {
    // console.log("selected " + rawObjects[index]["PFGE-XbaI-pattern"]);
}
    </script>
